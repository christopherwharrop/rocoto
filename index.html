<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Rocoto by christopherwharrop</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Rocoto</h1>
          <h2>Workflow Management System</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/christopherwharrop/rocoto/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/christopherwharrop/rocoto/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/christopherwharrop/rocoto" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1>

<p>Workflow Management is a concept that originated in the 1970's to handle business process management. Workflow management systems were developed to manage complex collections of business processes that need to be carried out in a certain way with complex interdependencies and requirements. Scientific Workflow Management is much newer, and is very much like its business counterpart, except that it is usually data oriented instead of process oriented. That is, scientific workflows are driven by the scientific data that "flows" through them. Scientific workflow tasks are usually triggered by the availability of some kind of input data, and a task's result is usally some kind of data that is fed as input to another task in the workflow. The individual tasks themselves are scientific codes that perform some kind of computation or retreive or store some type of data for a computation. So, whereas a business workflow is comprised of a diverse set of processes that have to be completed in a certain way, sometimes carried out by a machine, sometimes carried out by a human being, a scientific workflow is usually comprised of a set of computations that are driven by the availabiilty of input data.</p>

<h2>
<a id="why-workflow-management" class="anchor" href="#why-workflow-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why Workflow Management?</h2>

<p>The day when a scientist could conduct his or her numerical modeling and simulation research by writing, running, and monitoriing the progress of a modest Fortran code or two, is quickly becoming a distant memory. It is a fact that researchers now often have to make hundreds or thousands of runs of a numerical model to get a single result. In addition, each end-to-end "run" of the model often entails running many different codes for pre- and post-processing in addition to the model itself. And, in some cases, multiple models and their associated pre- and post-processing tasks are coupled together to build a larger, more complex model. The codes that comprise the end-to-end modeling systems often have complex interdependencies that dictate the order in which they can be run. And, in order to run the end-to-end system efficiently, concurrency must be used when dependencies allow it. The problem of scale and complexity is exacerbated by the fact that these codes are usually run on high performance machines that are notoriously difficult for scientists to use, and which tend to exhibit frequent failures. As machines get larger and larger, the failure rate of hardware and software components increases commensurately. Ad-hoc management of the execution of a complex modeling system is often difficult even for a single end-to-end run on a machine that never fails. Multiply that by the thousands of runs needed to perform a scientific experiment, in a hostile computing environment where hardware and facility outages are not uncommon, and you have a very challenging situation. For simulations that must run reliably in realtime, the situtation is almost hopeless. The traditional ad-hoc techniques for automating the execution of modeling systems (e.g. driver scripts, batch job chains or trees) do not provide sufficient fault tolerance for the scale and complexity of current and future workflows, nor are they reusable; each modeling system requires a custom automation system.</p>

<p>A Workflow Management System addresses the problems of complexity, scale, reliability, and reusability by providing two things:</p>

<ul>
<li>A high-level means by which to describe the various codes that need to be run, along with their runtime requirements and interdependencies.</li>
<li>An automation engine for reliably managing the execution of the workflow</li>
</ul>

<h2>
<a id="prerequisites" class="anchor" href="#prerequisites" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2>

<p>Depending on how the components of a modeling system are designed and how existing software for running them is designed, some changes may be necessary to make use of a workflow management system. In order to take full advantage of the features offered by a workflow management system, the model system components must be well designed. In particular the following best practices should be followed:</p>

<p>Each workflow task must correctly check for its successful completion, and must return a non-zero exit status upon failure. An exit status of 0 means success, regardless of what actually happened.
No workflow task should contain automation features. Automation is the workflow managmenet system's responsibility. A workflow management system cannot manage tasks or jobs that it is not aware of.
Enable reuse of workflow tasks by using principles of modular design to build autonomous model components with well-defined interfaces for input and output that can be run stand-alone.
Prefer the construction of small model components that do only one thing. It is easy to combine several small, well-designed, components together to build a larger, more complex workflow task. It is generally much more difficult to divide large, complex, model components into smaller ones to form multiple workflow tasks.
Avoid combining serial and parallel processing in the same workflow task unless the serial processing is very short in duration.</p>

<h1>
<a id="how-the-rocoto-workflow-management-engine-works" class="anchor" href="#how-the-rocoto-workflow-management-engine-works" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How The Rocoto Workflow Management Engine Works</h1>

<p>Our workflow managmement system, Rocoto, works differently than most other workflow management systems. It is designed to be a self-contained system that runs entirely in user space. That is, it is easy for end-users to install, and run without help from systems administrators. Rocoto interfaces to the local resource management system. It does not do any job scheduling itself, it merely submits jobs to the HPC system as task dependencies allow it. Local policies and users' allocations of HPC resources are enforced by the local resource management system (e.g. PBS, Torque, MOAB, SGE, LSF, etc.) so Rocoto has no control over when jobs start to run. Finally, Rocoto is designed to run weather and climate workflows; it is not a general purpose workflow management engine. Rocoto runs one instance of the workflow for a set of user-defined "cycles". A "cycle" usually corresponds to a model analysis or initialization time.</p>

<h2>
<a id="describing-workflows" class="anchor" href="#describing-workflows" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Describing Workflows</h2>

<p>Rocoto currently supports one method for describing workflows. Other methods may be made available in the future. Presently, users must define their workflows using a simple, custom XML language. The custom XML language consists of a set of tags and attributes that define what tasks are to be run and what their interdependencies are. They also define the runtime requirements of the tasks, such as batch queueing options and environment variables, as well as automation controls. Details of the XML language are given below.</p>

<h2>
<a id="executing-workflows" class="anchor" href="#executing-workflows" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Executing Workflows</h2>

<p>Rocoto is a Ruby program that interfaces to the underlying batch system. It does all the book keeping necessary to submit tasks when dependencies are satisfied and tracks the progress of the workflow. It will automatically resubmit failed tasks and can recover from system outages without human intervention.</p>

<p>The rocotorun command is used to "run" a workflow. And, as we describe below, this command must be executed many times in order to "run" a workflow to completion.</p>

<pre><code>rocotorun -w /path/to/workflow/xml/file -d /path/to/workflow/database/file
</code></pre>

<p>The rocotorun command requires two arguments. The -w flag specifies the name of the workflow definition file. For now, this must be an XML file containing the workflow definition. The -d flag specifies the name of the database file that is to be used to store the state of the workflow. The database file is a binary file created and used only by Rocoto and need not exist prior to the first time the command is run.</p>

<p>It is very important to understand that the process of "running" a workflow is iterative. Each time the above command is executed, Rocoto performs the following actions:</p>

<ol>
<li>Read the last known state of the workflow from the database file specified by the -d flag</li>
<li>Query the batch system to acquire the current state of the workflow</li>
<li>Take actions based on new state information. This includes things such as

<ol>
<li>Resubmit jobs that crashed</li>
<li>Submit jobs for tasks whose dependencies have just become satisfied</li>
</ol>
</li>
<li>Save the current state of the workflow to the file specified by the -d flag</li>
<li>Quit</li>
</ol>

<p>This means that each time Rocoto is run, there is an opportunity, but not a guarantee, for advancing the workflow's state toward completion. The amount of progress made each time Rocoto is run is nondeterministic and depends on many factors including the nature of the workflow being processed, load on the HPCS system, the batch system scheduler, delivery of data from external sources, etc. Rocoto typically runs for less than a minute each time it is invoked. It is important to understand that workflow state does not advance except when Rocoto is run; that is why it needs to be run repeatedly in order to run a workflow to completion. The primary advantage of this strategy of running workflows is that it is fault tolerant. Since each execution of the rocotorun command typically takes only a few seconds, the successful completion of a workflow does not hinge upon a machine being operational for the entire duration of the workflow (which could be days, months, years!). And, since the last known state of the workflow is saved on disk, rather than kept in volatile RAM, failure of the machine on which Rocoto is running does not require restarting the workflow from scratch or changing the workflow definition. Instead, as soon as the machine returns to operation, the workflow can be resumed from where it left off without having to modify the workflow definition at all. Further, if the database file is kept on a shared filesystem, the workflow can be resumed immediately using a different machine as long as that machine has access to the batch system.</p>

<p>Since the process of "running" workflows is iterative, it is usually necessary to run Rocoto as a cron job. Although running Rocoto repeatedly by hand is useful for testing and debugging, it is not tractable for production workflows. Rocoto should be run from cron at some regular interval, usually once every 2-10 minutes. The appropriate interval can be determined by looking at how long most jobs in the workflow take to run, and/or how crucial it is for new jobs to start as soon as their prerequisite jobs finish. A typical cron entry looks something like this.</p>

<pre><code>*/5 * * * * /path/to/rocotorun -w /path/to/workflow/definition/file -d /path/to/workflow/database/file
</code></pre>

<p>It is important to note that the times chosen in the crontab has nothing to do with when jobs are submitted. Rocoto determines when jobs are launched based on the cycle times and dependencies defined in the workflow definition file. The interval chosen for running Rocoto corresponds to the maximum amount of time that can pass between when a task's dependencies become satisfied and when that task gets submitted. The longest acceptable interval should be chosen. Excessively short duration between runs of Rocoto place unnecessary load on the system and do not allow the workflow to run any faster. In most cases is it inappropriate for non-realtime workflow to use an interval less than 5 minutes.</p>

<h2>
<a id="checking-the-status-of-workflows" class="anchor" href="#checking-the-status-of-workflows" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Checking the status of workflows</h2>

<p>Rocoto provides two tools for checking the status of workflows. These tools display status information and can help diagnose workflow problems.</p>

<p>The rocotostat tool allows the user to query the status of a set of cycles and tasks.</p>

<pre><code>rocotostat -w /path/to/workflow/xml/file -d /path/to/workflow/database/file [-c YYYYMMDDHHMM,[YYYYMMDDHHMM,...]] [-t taskname,[taskname,...]] [-s] [-T]
</code></pre>

<p>The -w and -d options identify which workflow run you want to query. The -c option allows you to select specific cycles to query. The -t option allows you to select specify tasks (some use of regular expression patterns are allowed). The -T option sorts the output by taskname rather than by cycle. The -s option will provide a summary report of the status of the cycles themselves rather than information about the tasks.</p>

<p>The rocotocheck tool allows users to query detailed information about a specific task for a specific cycle.</p>

<pre><code>rocotocheck -w /path/to/workflow/xml/file -d /path/to/workflow/database/file -c YYYYMMDDHHMM -t taskname
</code></pre>

<p>The -w and -d options identify which workflow run you want to query. The -c option identifies the cycle to query. The -t option identifies the task to query. All options are required. The -c and -t options can not be a list. This command provides a lot of detail about the particular task, including the reasons (if any) why it can not be submitted.</p>

<h2>
<a id="forcing-tasks-to-run" class="anchor" href="#forcing-tasks-to-run" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Forcing tasks to run</h2>

<p>Rocoto provides a tool, rocotoboot, that can be used to force a task to be submitted, regardless of whether or not dependencies are satisfied or throttling violations would occur. It CAN NOT be used to force tasks to run that have expired due to deadlines being reached or cycle life spans being exceeded.</p>

<pre><code>rocotoboot -w /path/to/workflow/xml/file -d /path/to/workflow/database/file -c YYYYMMDDHHMM -t taskname
</code></pre>

<p>The -w and -d options identify which workflow run you want to query. The -c option identifies the cycle to query. The -t option identifies the task to query. All options are required. The -c and -t options can not be a list.</p>

<h1>
<a id="rocoto-xml-language" class="anchor" href="#rocoto-xml-language" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rocoto XML Language</h1>

<p>Rocoto uses a very simple XML language to define workflows. It is specifically targeted for weather and climate simulations, and is not intended to be a catch-all for any type of simulation research. Therefore, it may not be amenable to certain types of research.</p>

<h2>
<a id="xml-header" class="anchor" href="#xml-header" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>XML Header</h2>

<p>Every XML file must have this text at the top:</p>

<pre><code>  &lt;?xml version="1.0"?&gt; 
  &lt;!DOCTYPE workflow
  [
  ]&gt;
</code></pre>

<p>This is required by XML parsers, and it tells the parsers what kind of document this is. It has no relevance to anything else in the workflow, and can be pretty much ignored.</p>

<h2>
<a id="entities" class="anchor" href="#entities" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ENTITIES</h2>

<p>The only exception to the above, is that it is often very nice to define constants, called ENTITIES, that can be referenced in other parts of the document. The use of ENTITIES is crucial for creating documents that are easy to maintain. The idea is that you use the ENTITY to represent a value that is used in lots of places in the XML. Then, if you ever have to change it, you only need to change it in one place. The definition of the ENTITIES go between the [ and the ] in the XML header shown above. For example,</p>

<pre><code>  &lt;?xml version="1.0"?&gt;
  &lt;!DOCTYPE workflow
  [
      &lt;!ENTITY WRF_HOME "/lfs0/projects/wrf/arw/13km"&gt;
  ]&gt;
</code></pre>

<p>In the above example, an ENTITY called WRF_HOME is defined and given a value of /lfs0/projects/wrf/arw/13km. Now, anytime we need to use /lfs0/projects/wrf/arw/13km later in the document, we can use the WRF_HOME ENTITY instead. Then, if the ENTITY definition for WRF_HOME is changed, all places where it is referenced will see the updated value. This has huge benefits for building XML documents that are easy to maintain.</p>

<p>An ENTITY is referenced by the following syntax: &amp;ENTITY_NAME;</p>

<p>And, you can reference an ENTITY when defining another ENTITY. For example,</p>

<pre><code>  &lt;?xml version="1.0"?&gt;
  &lt;!DOCTYPE workflow
  [ 
      &lt;!ENTITY WRF_HOME  "/lfs0/projects/wrf/arw/13km"&gt;
      &lt;!ENTITY LOG       "&amp;WRF_HOME;/log"&gt; 
  ]&gt;
</code></pre>

<p>In the above example, the LOG ENTITY references the WRF_HOME entity in its definition. So, changing the value of WRF_HOME will also change the value of LOG. ENTITIES can be used almost anywhere, but can not be used to hold the values of tag or attribute names. They can be used to hold attribute values, however. For example,</p>

<pre><code>  &lt;task name="wrf" maxtries="3"&gt;
</code></pre>

<p>In the above example, the SCRIPTS ENTITY is used when defining the value of the name attribute in a task tag.</p>

<h2>
<a id="the-workflow-tag" class="anchor" href="#the-workflow-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;workflow&gt; tag</h2>

<p>This is the main tag for defining workflows. Everything except for the header described above must be contained within the &lt;workflow&gt; tag. It has attributes for specifying the scheduler and throttling parameters.</p>

<h3>
<a id="the-realtime-attribute" class="anchor" href="#the-realtime-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The realtime attribute</h3>

<p>The realtime attribute defines whether or not the workflow is to be run in realtime, or in retrospective mode. If realtime is set to "T" or "True", the workflow will be run in realtime. If it is set to "F" or "False" it will be run in retrospective mode. The difference between realtime and retrospective mode is in how cycles are activated. In realtime mode, cycles are activated based on the current time of day. That is, the 00Z cycle for Jan 1, 2009 will be activated as soon as the current time of day is actually 00Z Jan 1, 2009. It will never be activated sooner or later than that time. In retrospective mode, there is no time dependency that must be adhered to. Thus, cycles will be activated immediately, in chronological order, subject to throttling constraints (described below). Each time Rocoto runs, new cycles may be activated if the throttling parameters allow it.</p>

<p>The following example illustrates how to set a workflow to run in realtime mode:</p>

<pre><code>  &lt;workflow realtime="T"&gt;

      Everything else goes in here

  &lt;/workflow&gt;
</code></pre>

<h3>
<a id="the-scheduler-attribute" class="anchor" href="#the-scheduler-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The scheduler attribute</h3>

<p>The scheduler attribute must be set to one of: sge, lsf, torque, moabtorque, or moab. This attribute tells Rocoto which batch system to use when managing the workflow. It is currently not possible to use more than one batch system within the same workflow. On Jet and Zeus, the value should be moabtorque. On Gaea, the value should be moab. On Yellowstone and Geyser, the value should be lsf. On WCOSS, the value should be lsf. NOTE: In order for Rocoto to operate correctly with the Torque and MoabTorque schedulers those resource management systems must be configured to keep information about completed jobs long enough such that Rocoto can retrieve the information after the jobs have finished. It is recommended that the keep time be set to a minimum of 24 hours.</p>

<pre><code>  &lt;workflow realtime="F" scheduler="moabtorque"&gt;

      Everything else goes here 

  &lt;/workflow&gt;
</code></pre>

<h3>
<a id="the-cyclelifespan-attribute" class="anchor" href="#the-cyclelifespan-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The cyclelifespan attribute</h3>

<p>The cyclelifespan attribute specifies how long a cycle can be active before it expires. The length of time is specified in dd:hh:mm:ss format. This attribute is most useful for realtime workflows in situations where you want to stop processing a cycle after some deadline, regardless of whether it has completed successfully or not. Wall clock time requests are automatically capped such that they will not exceed the time when a cycle expires.</p>

<p>For example, the following will cause cycles to expire one hour after they are activated</p>

<pre><code>  &lt;workflow realtime="F" scheduler="moabtorque" cyclelifespan="0:01:00:00"&gt;

      Everything else goes here 

  &lt;/workflow&gt;
</code></pre>

<h3>
<a id="the-cyclethrottle-attribute" class="anchor" href="#the-cyclethrottle-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The cyclethrottle attribute</h3>

<p>The cyclethrottle attribute allows you to limit how many cycles may be active at one time. This is probably most useful for retrospective workflows and helps users manage the cpu and disk resources your workflows consume. Cycles are active if they have not expired and not all tasks for the cycle have completed successfully</p>

<p>For example, the following will prevent more than 5 cycles from being active at one time.</p>

<pre><code>  &lt;workflow realtime="F" scheduler="moabtorque" cyclelifespan="0:01:00:00" cyclethrottle="5"&gt;

      Everything else goes here 

  &lt;/workflow&gt;
</code></pre>

<h3>
<a id="the-corethrottle-attribute" class="anchor" href="#the-corethrottle-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The corethrottle attribute</h3>

<p>The corethrottle attribute allows you to limit the total number of cores that may be consumed by jobs submitted to the batch system. This is probably most useful for retrospective workflows and helps users manage the cpu and disk resources your workflows consume. Any job that is submitted to the batch system, whether it is running or queued, counts against this total.</p>

<p>For example, the following will prevent more than 3 cores from being consumed by queued or running jobs.</p>

<pre><code>  &lt;workflow realtime="F" scheduler="moabtorque" cyclelifespan="0:01:00:00" cyclethrottle="5" corethrottle="3"&gt;

      Everything else goes here 

  &lt;/workflow&gt;
</code></pre>

<h3>
<a id="the-taskthrottle-attribute" class="anchor" href="#the-taskthrottle-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The taskthrottle attribute</h3>

<p>The taskthrottle attribute allows you to limit how many tasks may be active at one time. This is probably most useful for retrospective workflows and helps users manage the cpu and disk resources your workflows consume. A task is active if a job has been submitted for it and that job has not finished. Any job that is submitted to the batch system, whether it is running or queued, counts against this total.</p>

<p>For example, the following will prevent more than 5 tasks from being active at one time.</p>

<pre><code>  &lt;workflow realtime="F" scheduler="moabtorque" cyclelifespan="0:01:00:00" cyclethrottle="5" taskthrottle="5"&gt;

      Everything else goes here 

  &lt;/workflow&gt;
</code></pre>

<h2>
<a id="the-log-tag" class="anchor" href="#the-log-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;log&gt; tag</h2>

<p>The &lt;log&gt; tag defines the path and name of Rocoto log(s). It can be anything, but usually it is best to define the name of the log to be dynamically dependent on the cycle being processed. This will put everything for a particular cycle in its own log file.</p>

<pre><code>  &lt;workflow realtime="T" scheduler="moabtorque" cyclelifespan="0:01:00:00" cyclethrottle="5" corethrottle="3"&gt;

      &lt;log&gt;&lt;cyclestr&gt;&amp;LOG;/workflow_@Y@m@d@H.log&lt;/cyclestr&gt;&lt;/log&gt;

      Everything else goes here 

  &lt;/workflow&gt;
</code></pre>

<p>In the above example, the workflow log is defined to be named /lfs0/projects/wrf/arw/13km/log/workflow_yyyymmddhh.log where yyyymmddhh represents the cycle time. Note the use of the LOG ENTITY to represent the path of the log file. The &lt;cyclestr&gt; tag is special and is described below.</p>

<h2>
<a id="the-cyclestr-tag" class="anchor" href="#the-cyclestr-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;cyclestr&gt; tag</h2>

<p>It is often necessary to refer to the various components of the current cycle time when defining various aspects of the workflow. For example, when defining the name of the workflow log as in the previous example above, we need to specify the year, month, day, and hour of the cycle. Since the cycle is a dynamic quantity, we can't just put the value in there, we need a special tag to represent it. The cyclestr tag accomplishes this. The &lt;cyclestr&gt; tag uses flags to represent the various time components of the current cycle:</p>

<pre><code>   @a The abbreviated weekday name ("Sun")
   @A The full weekday name ("Sunday")
   @b The abbreviated month name ("Jan")
   @B The full month name ("January")
   @c The preferred local date and time representation ("Thu Jul  5 11:27:59 2012")
   @d Day of month (01..31)
   @H Hour of the day, 24 hour clock (00..23)
   @I Hour of the day, 12 hour clock (01..12)
   @j Day of the year (001..366)
   @m Month of the year (01..12)
   @M Minute of the hour (00..59)
   @p Meridian indicator ("AM" or "PM")
   @P Meridian indicator ("am" or "pm")
   @s Number of seconds since January 1, 1970 00:00:00 UTC
   @S Second of the minute (00..60)
   @U Week number of the current year, starting with the first Sunday as the first day of the first week (00..53)
   @W Week number of the current year, starting with the first Monday as the first day of the first week (00..53)
   @w Day of week (Sunday is 0, 0..6)
   @x Preferred representation for the date alone ("07/05/12")
   @X Preferred representation for the time along ("11:34:58")
   @y Year without century (00..99)
   @Y Year with century
   @Z Time zone name
</code></pre>

<p>Rocoto may be processing multiple cycles at once. Any time one of the above flags appears inside a &lt;cyclestr&gt; ... &lt;/cyclestr&gt; block, those flags will be replaced with the appropriate date/time component of the current cycle being processed. These flags can be used in any combination to represent any date/time string desired. For example,</p>

<pre><code>  &lt;cyclestr&gt;@Y@m@d@H&lt;/cyclestr&gt;
</code></pre>

<p>One very nice feature is that other text can appear within a &lt;cyclestr&gt; tag. For example,</p>

<pre><code>  &lt;log&gt;&lt;cyclestr&gt;/my/path/to/the/log/file/workflowlog_@Y@m@d@H&lt;/cyclestr&gt;&lt;/log&gt;
</code></pre>

<p>The line above shows how the &lt;cyclestr&gt; tag might be used inside a &lt;log&gt; tag to specify the names of Rocoto log files.</p>

<h3>
<a id="the-offset-attribute" class="anchor" href="#the-offset-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The offset attribute</h3>

<p>Sometimes it is necessary to be able to represent not just the current cycle, but some offset before or after the current cycle. This can be accomplished through the use of the offset attribute. The offset attribute should be set to the time that needs to be added to the current cycle time to yield the time that is desired. The format of the offset attribute is dd:hh:mm:ss where dd=days, hh=hours, mm=minutes, and ss=seconds. Also, leading fields whose values are 0 do not need to be specified. For example, all of the following are equivalent:</p>

<pre><code>  &lt;cyclestr offset="3600"&gt;@Y@m@d@H&lt;/cyclestr&gt;

  &lt;cyclestr offset="1:00:00"&gt;@Y@m@d@H&lt;/cyclestr&gt;

  &lt;cyclestr offset="00:60:00"&gt;@Y@m@d@H&lt;/cyclestr&gt;

  &lt;cyclestr offset="60:00"&gt;@Y@m@d@H&lt;/cyclestr&gt;
</code></pre>

<p>All of the above represents the yyyymmddHH of the current cycle, plus one hour. The offset can also be negative. To represent one hour earlier than the cycle time, simply make the first character of the offset a minus sign. Use of the full time representation is highly recommended to make your workflows easier to read. Consider, for example, which of the following two equivalent XML is easier to interpret:</p>

<pre><code>  &lt;cyclestr offset="-9:00:00"&gt;@H&lt;/cyclestr&gt;

  &lt;cyclestr offset="-32400"&gt;@H&lt;/cyclestr&gt;
</code></pre>

<p>Both of the above specify the hour that is 9 hours previous to the current cycle, but most people don't know off the top of their heads that there are 32400 seconds in 9 hours, so the first form is more readable.</p>

<h2>
<a id="the-cycledef-tag" class="anchor" href="#the-cycledef-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;cycledef&gt; tag</h2>

<p>The &lt;cycledef&gt; tag defines the set of cycles the workflow is to be run on. You can have as many &lt;cycledef&gt; tags as you want. In some cases, it may be necessary to use multiple &lt;cycle&gt; tags to represent the set of cycles desired. Rocoto uses the union of all sets of cycles specified by the &lt;cycledef&gt; tags to create the overall cycle pool. If there is overlap between definitions, it will not cause cycles to be run twice. There are two ways to specifies cycles. You may mix and match the two different ways to specify cycles as needed.</p>

<h3>
<a id="the-start-stop-step-method" class="anchor" href="#the-start-stop-step-method" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The start, stop, step method</h3>

<p>The first method for specifying cycles is to specify a start cycle, an end cycle, and an increment. The format of the start and stop cycles is yyyymmddhhmm. The format of the increment is dd:hh:mm:ss.</p>

<p>For example,</p>

<pre><code>  &lt;workflow realtime="T"&gt;

      &lt;log&gt;&lt;cyclestr&gt;&amp;LOG;/workflow_@Y@m@d@H.log&lt;/cyclestr&gt;&lt;/log&gt;

      &lt;cycledef&gt;201101010000 201112311800 06:00:00&lt;/cycledef&gt; 

  &lt;/workflow&gt;
</code></pre>

<p>The &lt;cycledef&gt; tag in the example above specifies all 00Z, 06Z, 12Z, and 18Z cycles beginning with January 1, 2011 00:00:00 and ending with December 31, 2011 18:00:00.</p>

<h3>
<a id="the-crontab-like-method" class="anchor" href="#the-crontab-like-method" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The crontab-like method</h3>

<p>The second method for specifying cycles is to use a crontab-like format to represent groups of cycles. There are six fields that must be defined: minute, hour, day, month, year, and weekday. Each field can be a single value, a range of values, a comma separated list of values, etc.</p>

<pre><code>  &lt;workflow realtime="T"&gt;

     &lt;log&gt;&lt;cyclestr&gt;&amp;LOG;/workflow_@Y@m@d@H.log&lt;/cyclestr&gt;&lt;/log&gt;

     &lt;cycledef group="15min"&gt;*/15 * * * 2006-2010 *&lt;/cycledef&gt; 

     &lt;cycledef group="hourly"&gt;0 * * * 2006-2010 *&lt;/cycledef&gt; 

     &lt;cycledef group="3hourly"&gt;0 */3 * * 2006-2010 *&lt;/cycledef&gt; 

     &lt;cycledef group="6hrlyJanFeb"&gt;0 */6 * 1,2 2006-2010 *&lt;/cycledef&gt; 

  &lt;/workflow&gt;
</code></pre>

<p>The above example shows four &lt;cycledef&gt; tags. Each of these defines a list of minutes, hours, days, months, years, and weekdays. A * is shorthand for all values of that field. So, the * in the second field means all hours. And the * in the third field means all days. In the example above, the first &lt;cycledef&gt; defines a set of cycles consisting of every 15 minutes of every hour for every day and every month of the years 2006-2010. The second &lt;cycledef&gt; tag defines a set of cycles consisting of minute 0 of every hour of every day for the years 2006 thru 2010.</p>

<h3>
<a id="the-group-attribute" class="anchor" href="#the-group-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The group attribute</h3>

<p>Sometimes it is necessary to define distinct sets of cycles because some tasks should only be run for certain subsets of cycles. The group attribute of the &lt;cycledef&gt; tag allows you to assign a set of cycles to a group that can later be used to control which tasks are run for which cycles. Multiple &lt;cycledef&gt; tags may be assigned to the same group, but a &lt;cycledef&gt; tag may not be assigned to more than one group.</p>

<h2>
<a id="the-task-tag" class="anchor" href="#the-task-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;task&gt; tag</h2>

<p>The &lt;task&gt; tag is the bread and butter of the workflow. It defines the computations that you want to run. The example below shows the basic form of the &lt;task&gt; tag. The contents of the &lt;task&gt; tag have been left out for now for clarity.</p>

<pre><code>  &lt;workflow realtime="T"&gt;

     &lt;log&gt;&lt;cyclestr&gt;&amp;LOG;/workflow_@Y@m@d@H.log&lt;/cyclestr&gt;&lt;/log&gt;

     &lt;cycledef&gt;201101010000 201112311800 06:00:00&lt;/cycledef&gt; 
     &lt;cycledef group="15min"&gt;*/15 * * * 2006-2010 *&lt;/cycledef&gt; 
     &lt;cycledef group="hourly"&gt;0 * * * 2006-2010 *&lt;/cycledef&gt; 
     &lt;cycledef group="3hourly"&gt;0 */3 * * 2006-2010 *&lt;/cycledef&gt; 
     &lt;cycledef group="6hrlyJanFeb"&gt;0 */6 * 1,2 2006-2010 *&lt;/cycledef&gt; 

     &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;/task&gt;

  &lt;/workflow&gt;
</code></pre>

<p>In the example above, a task named wrf has been defined. The attributes are described below</p>

<p>The command that does this task's work is the wrf.ksh script in the path represented by the &amp;SCRIPTS; ENTITY. The task is set to run for the set of cycles represented by the cycles whose ids are 6hr, and 12hr. The batch scheduler for this task is SGE. No more than 5 instances of this task can be submitted and/or running simultaneously. Rocoto will make no more than 3 attempts at running this task if it fails. More details are described below.
The name attribute</p>

<p>Every task must have a unique name defined. It can be almost anything, but there can never be two tasks in the same workflow with the same name. This name is used to define task dependencies which are described later.</p>

<h3>
<a id="the-cycledefs-attribute" class="anchor" href="#the-cycledefs-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The cycledefs attribute</h3>

<p>The cycledefs attribute is optional. If set, its value must be a comma separated list of &lt;cycledef&gt; tag group names. If it is not set, the task will be run for every cycle in the general pool of cycles. The general pool of cycles is the union of all sets of cycles, both with, and without group ids, specified in the &lt;cycledef&gt; tags. If the cycledefs attribute is set, the task will only be run for cycles that are defined by the &lt;cycledef&gt; tags having the group ids listed.</p>

<h3>
<a id="the-maxtries-attribute" class="anchor" href="#the-maxtries-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The maxtries attribute</h3>

<p>The maxtries attribute is optional. When Rocoto detects that a task has failed, it will attempt to resubmit it. The maxtries attribute limits the number of times a task can be retried before Rocoto gives up.</p>

<p>HINT: If the number of tries has been exhausted, but you want to retry it one more time, just modify the XML on-the-fly and increment this value. Rocoto will rerun the task again unless the cycle has expired.</p>

<h3>
<a id="the-throttle-attribute-version-11-and-higher" class="anchor" href="#the-throttle-attribute-version-11-and-higher" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The throttle attribute (version 1.1 and higher)</h3>

<p>The throttle attribute is optional. If set, its value must be a positive integer. The throttle limits the number of instances of the task which may be queued or running at any one time. There is one instance of the task per cycle. Therefore, the task throttle limits the number of cycles for which the task may be active at any one time.</p>

<p>HINT: The &lt;task&gt; throttle attribute should be avoided. In most situations, the various &lt;workflow&gt; throttles and/or the &lt;metatask&gt; throttle provide far better throttling control and should always be preferred. Do not use the &lt;task&gt; throttle unless the other throttling methods cannot meet the throttling requirements of the workflow</p>

<h2>
<a id="the-command-tag" class="anchor" href="#the-command-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;command&gt; tag</h2>

<p>Every &lt;task&gt; tag must contain a &lt;command&gt; tag. This is the command that carries out the task's work and is the command that Rocoto will submit to the batch system for execution. Command arguments are permitted.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the--tag" class="anchor" href="#the--tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The  tag</h2>

<p>Every &lt;task&gt; tag should contain a &lt;account&gt; tag. However, it is optional to allow for situations where a default may be used. This defines the batch system account/project that Rocoto will use when submitting the task to the batch system for execution. This is usually not the same thing as the user's login name.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-queue-tag" class="anchor" href="#the-queue-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;queue&gt; tag</h2>

<p>Every &lt;task&gt; tag should contain a &lt;queue&gt; tag. However, it is optional to allow for situations where a default may be used. This defines the batch system queue that Rocoto will submit the task to for execution. The queue name is inherently machine specific.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-cores-tag" class="anchor" href="#the-cores-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;cores&gt; tag</h2>

<p>Every &lt;task&gt; tag must contain either one &lt;cores&gt; tag or one &lt;nodes&gt; (see below) tag. The &lt;cores&gt; tag defines the number of cores that Rocoto will request when submitting the task for execution.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-nodes-tag-version-11-and-higher" class="anchor" href="#the-nodes-tag-version-11-and-higher" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;nodes&gt; tag (version 1.1 and higher)</h2>

<p>Every &lt;task&gt; tag must contain either one &lt;nodes&gt; tag or one &lt;cores&gt; (see above) tag. The &lt;nodes&gt; tag defines the task geometry (a list of node counts and cores per node) that Rocoto will request when submitting the task for execution. The &lt;cores&gt; tag should always be preferred. The &lt;nodes&gt; tag should only be used if the task has a requirement to use less than all of the available cores on at least one of its nodes. The &lt;nodes&gt; tag is primarily intended to support OpenMP/MPI hybrid codes, MPMD codes that consist of multiple components that must not share nodes, and parallel codes that require some ranks to be on their own nodes for memory consumption reasons.</p>

<p>The format of the contents of the &lt;nodes&gt; tag is very similar to the syntax of the Moab/Torque "-l nodes=..." option. The differences are that the "ppn" (processes per node) is always required, and there is an optional "tpp" (threads per process) that should be used for OpenMP/MPI hybrid tasks. The format of &lt;nodes&gt; is easiest to illustrate with examples.</p>

<p>For single threaded codes (i.e. processes do not spawn threads):</p>

<pre><code>  &lt;nodes&gt;1:ppn=1&lt;/nodes&gt;                             &lt;!-- request 1 core on each of 1 nodes --&gt; 
  &lt;nodes&gt;1:ppn=4&lt;/nodes&gt;                             &lt;!-- request 4 cores on each of 1 nodes --&gt;
  &lt;nodes&gt;10:ppn=4&lt;/nodes&gt;                           &lt;!-- request 4 cores on each of 10 nodes --&gt;
  &lt;nodes&gt;1:ppn=1+10:ppn=12&lt;/nodes&gt;            &lt;!-- request 1 core on the first 1 nodes and 12 cores on each of the next 10 nodes --&gt;
  &lt;nodes&gt;1:ppn=1+2:ppn=4+3:ppn=8&lt;/nodes&gt;  &lt;!-- request 1 core on the first 1 nodes, 4 cores on each of the next 2 nodes, and 8 cores on each of the last 3 nodes --&gt;
</code></pre>

<p>For threaded applications (e.g. OpenMP/Hybrid codes), you must specify the number of threads each process will spawn:</p>

<pre><code>  &lt;nodes&gt;1:ppn=1:tpp=12&lt;/nodes&gt;                                     &lt;!-- request 1 core on each of 1 nodes, each process will spawn 12 threads --&gt;
  &lt;nodes&gt;1:ppn=4:tpp=3&lt;/nodes&gt;                                       &lt;!-- request 4 cores on each of 1 nodes, each process will spawn 3 threads --&gt;
  &lt;nodes&gt;10:ppn=4:tpp=3&lt;/nodes&gt;                                     &lt;!-- request 4 cores on each of 10 nodes, each process will spawn 3 threads --&gt;
  &lt;nodes&gt;1:ppn=1+10:ppn=12&lt;/nodes&gt;                               &lt;!-- request 1 core on the first 1 nodes and 12 cores on each of the next 10 nodes, by default none of the processes are threaded --&gt;
  &lt;nodes&gt;1:ppn=1+2:ppn=4:tpp=4+3:ppn=8:tpp=2&lt;/nodes&gt;  &lt;!-- request 1 core on the first 1 nodes, 4 cores and 4 threads per process on each of the next 2 nodes, and 8 cores and 2 threads per process on each of the last 3 nodes --&gt;
</code></pre>

<p>Finally, the following shows a simple example in context of the &lt;task&gt; tag.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;nodes&gt;1:ppn=1+10:ppn=12&lt;/nodes&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-walltime-tag" class="anchor" href="#the-walltime-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;walltime&gt; tag</h2>

<p>Every &lt;task&gt; tag must contain a &lt;walltime&gt; tag. This defines the amount of wallclock time that Rocoto will request when submitting the task to for execution. The requested walltime is automatically reduced so as not to exceed the amount of time remaining before the task expires.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-memory-tag" class="anchor" href="#the-memory-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;memory&gt; tag</h2>

<p>The &lt;memory&gt; tag is usually only needed for serial tasks. This defines the amount of memory that Rocoto will request when submitting the task to for execution.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

     &lt;memory&gt;512M&lt;/memory&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-jobname-tag" class="anchor" href="#the-jobname-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;jobname&gt; tag</h2>

<p>Every &lt;task&gt; tag should contain a &lt;jobname&gt; tag because it helps in visual tracking of jobs in queue status outputs. However, it is optional to allow for situations where a default may be used. This defines the name that will be assigned to the job when submitting the task for execution.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

     &lt;memory&gt;512M&lt;/memory&gt;

     &lt;jobname&gt;test&lt;/jobname&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-deadline-tag" class="anchor" href="#the-deadline-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;deadline&gt; tag</h2>

<p>Every &lt;task&gt; tag may contain a &lt;deadline&gt; tag to specify a time by which the task must complete successfully. This time should be in YYYYMMDDHHMM format, which means that its contents should usually be a &lt;cyclestr&gt; tag with a positive offset. Wall clock time requests specified in &lt;walltime&gt; tags are automatically capped at job submission such that they will not exceed the deadline.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

     &lt;memory&gt;512M&lt;/memory&gt;

     &lt;jobname&gt;test&lt;/jobname&gt;

     &lt;deadline&gt;&lt;cyclestr offset="2:00:00"&gt;@Y@m@d@H@M&lt;/cyclestr&gt;&lt;/deadline&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-stdout-stderr-and-join-tags" class="anchor" href="#the-stdout-stderr-and-join-tags" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;stdout&gt;, &lt;stderr&gt;, and &lt;join&gt; tags</h2>

<p>Every &lt;task&gt; tag should contain either both &lt;stdout&gt; and &lt;stderr&gt; tags, or a &lt;join&gt; because it helps in tracking and finding the output of your jobs. However, they are optional to allow for situations where defaults may be used. These tags define the location of the stdout and stderr output of the job that executes the task. If either or both &lt;stdout&gt; and &lt;stderr&gt; are used, &lt;join&gt; may not be used. If &lt;join&gt; is used, neither &lt;stdout&gt; or &lt;stderr&gt; may be used. The &lt;join&gt; tag is used when you want both stdout and stderr to go to the same place. DO NOT set the value of &lt;stdout&gt; and &lt;stderr&gt; to the same thing; use &lt;join&gt; to do that.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

     &lt;memory&gt;512M&lt;/memory&gt;

     &lt;jobname&gt;test&lt;/jobname&gt;

     &lt;join&gt;/home/harrop/test/log/test.join&lt;/join&gt;

  &lt;/task &gt;
</code></pre>

<p>Or</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

     &lt;memory&gt;512M&lt;/memory&gt;

     &lt;jobname&gt;test&lt;/jobname&gt;

     &lt;stdout&gt;/home/harrop/test/log/test.out&lt;/stdout&gt;

     &lt;stderr&gt;/home/harrop/test/log/test.err&lt;/stderr&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-native-tag" class="anchor" href="#the-native-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;native&gt; tag</h2>

<p>This tag may be used to define raw batch system options that Rocoto will use when submitting jobs for this &lt;task&gt;. This is useful in cases where an option is required but is not (yet) implemented as a generic tag. For example, this can be used when requesting advanced reservations or partitions). Multiple instances of &lt;native&gt; are not allowed. If more than one native option is required, all of them must be specified within a single &lt;native&gt; tag.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

     &lt;memory&gt;512M&lt;/memory&gt;

     &lt;jobname&gt;test&lt;/jobname&gt;

     &lt;join&gt;/home/harrop/test/log/test.join&lt;/join&gt;

     &lt;native&gt;-m e -M Christopher.W.Harrop@noaa.gov&lt;/native&gt;

  &lt;/task &gt;
</code></pre>

<h2>
<a id="the-envar-tag" class="anchor" href="#the-envar-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;envar&gt; tag</h2>

<p>The &lt;envar&gt; tag is used inside &lt;task&gt; tags to define environment variables that must be passed to the task when it is executed. It consists of (name,value) pairs. All &lt;envar&gt; tags must contain a &lt;name&gt; tag. However, &lt;value&gt; tags can be absent in cases where a variable needs to be set, but does not need to be assigned a value.</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     &lt;command&gt;&lt;cyclestr&gt;&amp;SCRIPTS;/wrf.ksh -c @Y@m@d@H&lt;/cyclestr&gt;&lt;/command&gt;

     &lt;account&gt;dtc&lt;/account&gt;

     &lt;queue&gt;nserial&lt;/queue&gt;

     &lt;cores&gt;1&lt;/cores&gt;

     &lt;walltime&gt;00:00:10&lt;/walltime&gt;

     &lt;memory&gt;512M&lt;/memory&gt;

     &lt;jobname&gt;test&lt;/jobname&gt;

     &lt;join&gt;/home/harrop/test/log/test.join&lt;/join&gt;

     &lt;native&gt;-m e -M Christopher.W.Harrop@noaa.gov&lt;/native&gt;

     &lt;envar&gt;
        &lt;name&gt;ANALYSIS_TIME&lt;/name&gt; 
        &lt;value&gt;&lt;cyclestr&gt;@Y@m@d@H@M&lt;/cyclestr&gt;&lt;/value&gt; 
     &lt;/envar&gt; 
     &lt;envar&gt; 
        &lt;name&gt;WRF_HOME&lt;/name&gt;
        &lt;value&gt;&amp;WRF_HOME;&lt;/value&gt; 
     &lt;/envar&gt; 

  &lt;/task &gt;
</code></pre>

<p>In the above example, the ANALYSIS_TIME and WRF_HOME environment variables will be set to the values given (note the use of the cyclestr tags and ENTITIES) and passed to the task when it executes. This is an alternative method for passing parameters to the scripts when tasks are run</p>

<h2>
<a id="the-dependency-tag" class="anchor" href="#the-dependency-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;dependency&gt; tag</h2>

<p>&lt;dependency&gt; tags are fundamental to every workflow. They are used inside &lt;task&gt; tags, and are used to describe the inter-dependencies of the tasks. It is this tag that is used to define things like "task B can't run until task A is complete", or "Task A can't run until this file shows up". Dependencies are defined as boolean expressions, which means that you have quite a lot of control over when tasks are eligible to run. There are three types of dependencies:</p>

<p>Task Dependencies
Data Dependencies
Time Dependencies
These dependencies can be combined in any combination in a boolean expression to form a task's overall dependency.</p>

<pre><code>   &lt;dependency&gt; 

     Dependencies go here          

   &lt;/dependency&gt;
</code></pre>

<p>The above example shows the basic format of the &lt;dependency&gt; tag. Inside the &lt;dependency&gt; tag there must be exactly one tag. The one tag inside the &lt;dependency&gt; tag must be one of the following tags:</p>

<pre><code>  &lt;taskdep&gt;
  &lt;datadep&gt;
  &lt;timedep&gt;
  &lt;streq&gt;
  &lt;strneq&gt;
  &lt;/true&gt;
  &lt;/false&gt;
  &lt;sh&gt;
  &lt;ruby&gt;
  &lt;cycleexistdep&gt;  
  &lt;and&gt;
  &lt;or&gt;
  &lt;not&gt;
  &lt;nand&gt;
  &lt;nor&gt;
  &lt;xor&gt;
  &lt;some&gt;
</code></pre>

<h2>
<a id="the-taskdep-tag" class="anchor" href="#the-taskdep-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;taskdep&gt; tag</h2>

<p>Task dependencies are defined inside &lt;dependency&gt; tags with the &lt;taskdep&gt; tag as in the following example:</p>

<pre><code>  &lt;task name="wrf" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     Other tags left out for clarity

     &lt;dependency&gt; 
        &lt;taskdep task="real"/&gt; 
     &lt;/dependency&gt;

  &lt;/task&gt;
</code></pre>

<p>The task attribute of the &lt;taskdep&gt; tag must be set to the name of the task which must complete in order for the dependency to be satisfied. The task attribute must refer to a task that has already been defined above in the XML document. That requirement ensures there are no circular dependencies.</p>

<h3>
<a id="the-cycle_offset-attribute" class="anchor" href="#the-cycle_offset-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The cycle_offset attribute</h3>

<p>In some cases a task may have a dependency on a task from a different cycle. The cycle_offset attribute allows users to specify an offset from the current cycle to define inter cycle dependencies. The offset can be positive or negative. The following example illustrates a dependency on a task from the cycle 6 hours prior to the current cycle.</p>

<pre><code>  &lt;task name="ungrib" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     Other tags left out for clarity

     &lt;dependency&gt; 
        &lt;taskdep task="wrfpost_f006" cycle_offset="-6:00:00"/&gt; 
     &lt;/dependency&gt;

  &lt;/task&gt;
</code></pre>

<h3>
<a id="the-state-attribute" class="anchor" href="#the-state-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The state attribute</h3>

<p>The "state" attribute is optional. It allows you to specify whether you want the dependency to be satisfied when a task has completed successfully, or when a task has failed and exhausted retries. The state attribute may be set to either "Succeeded" or "Dead". The default value is Succeeded if the attribute is not specified. For example, the following is a dependency that will be satisfied when task completes successfully.</p>

<pre><code>  &lt;taskdep state="succeeded" task="X"/&gt;
</code></pre>

<p>For example, the following is a dependency that will be satisfied when task X is has failed and has also exhausted retries</p>

<pre><code>  &lt;taskdep state="Dead" task="X"/&gt;
</code></pre>

<h2>
<a id="the-metataskdep-tag-version-11-and-higher" class="anchor" href="#the-metataskdep-tag-version-11-and-higher" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;metataskdep&gt; tag (version 1.1 and higher)</h2>

<p>Metatask dependencies are defined inside &lt;dependency&gt; tags with the &lt;metataskdep&gt; tag as in the following example:</p>

<pre><code>  &lt;task name="plots" cycledefs="3hourly,6hrlyJanFeb" maxtries="3"&gt;

     Other tags left out for clarity

     &lt;dependency&gt;
        &lt;metataskdep metatask="posts"/&gt;
     &lt;/dependency&gt;

  &lt;/task&gt;
</code></pre>

<p>The metatask attribute of the &lt;metataskdep&gt; tag must be set to the name of the metatask whose contents must complete in order for the dependency to be satisfied. The metatask attribute must refer to a task that has already been defined above in the XML document. in the following example:</p>

<pre><code>  &lt;datadep age="120"&gt;&lt;cyclestr&gt;&amp;WRF_HOME;/wrfprd/wrfout_d01_@Y-@m-@d_@H:@M:@S&lt;/cyclestr&gt;&lt;/datadep&gt;
</code></pre>

<p>File dependencies are satisfied when the file in question exists, has not been modified for at least the amount of time specified by age, and is at least as large as the size specified by minsize</p>

<h3>
<a id="the-age-attribute" class="anchor" href="#the-age-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The age attribute</h3>

<p>The age attribute of the &lt;datadep&gt; tag is optional. It contains the time (in dd:hh:mm:ss format) that the file must not be modified before the file is considered to be available. This is useful for preventing partially written files from erroneously triggering the submission of a task. As with the offset attributes of the &lt;cyclestr&gt; and cycle component tags, leading 0's can be left off. The default for this attribute is 0. For examples, see below.</p>

<h3>
<a id="the-minsize-attribute" class="anchor" href="#the-minsize-attribute" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The minsize attribute</h3>

<p>The minsize attribute of the &lt;datadep&gt; tag is optional. It contains the minimum size for the file before it is considered to be available. This is useful for preventing partially filled files from erroneously triggering the submission of a task. The default value for this attribute is 0. The units of the minsize attribute may optionally be specified by setting the last character of the value to one of</p>

<p>B or b: Size in bytes
K or k: Size in kilobytes
M or m: Size in megabytes
G or g: Size in gigabytes
If no units are specified, the units are bytes.</p>

<pre><code>  &lt;datadep age="120" minsize="1024"&gt;&lt;cyclestr&gt;&amp;WRF_HOME;/wrfprd/wrfout_d01_@Y-@m-@d_@H:@M:@S&lt;/cyclestr&gt;&lt;/datadep&gt;

  &lt;datadep age="00:00:02:00" minsize="1024B"&gt;&lt;cyclestr&gt;&amp;WRF_HOME;/wrfprd/wrfout_d01_@Y-@m-@d_@H:@M:@S&lt;/cyclestr&gt;&lt;/datadep&gt;

  &lt;datadep age="02:00" minsize="1024b"&gt;&lt;cyclestr&gt;&amp;WRF_HOME;/wrfprd/wrfout_d01_@Y-@m-@d_@H:@M:@S&lt;/cyclestr&gt;&lt;/datadep&gt;

  &lt;datadep age="00:02:00" minsize="1K"&gt;&lt;cyclestr&gt;&amp;WRF_HOME;/wrfprd/wrfout_d01_@Y-@m-@d_@H:@M:@S&lt;/cyclestr&gt;&lt;/datadep&gt;
</code></pre>

<p>All the lines above are equivalent</p>

<h2>
<a id="the-timedep-tag" class="anchor" href="#the-timedep-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;timedep&gt; tag</h2>

<p>Time dependencies are defined with the &lt;timedep&gt; tag. The value between the start and end of the &lt;timedep&gt; tag is a time in yyyymmddhhmmss format. Time dependencies are satisfied with the wall clock time is equal to or greater than the time specified. All times are calculated in GMT.</p>

<pre><code>  &lt;timedep&gt;&lt;cyclestr offset="&amp;DEADLINE;"&gt;@Y@m@d@H@M@S&lt;/cyclestr&gt;&lt;/timedep&gt;
</code></pre>

<h2>
<a id="the-streq-tag" class="anchor" href="#the-streq-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;streq&gt; tag (version 1.2.2+)</h2>

<p>The string comparison tags can be used to create dependency switches in your XML that allow you to manually (but easily) turn parts of a workflow on/off.  This can be useful in cases where there are multiple possible workflow configurations that are very similar to each other.  Rather than creating and maintaining separate workflows for each mostly identical configuration, these switches can be used to define a single workflow that can then be configured for various scenarios. For example, you could turn the "GSI" task of your workflow on/off with a &lt;streq&gt; dependency defined in each task that runs only when the GSI is turned "on":</p>

<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE workflow
[
 ...
  &lt;!ENTITY RUN_GSI "YES"&gt;
]&gt;

...

&lt;dependency&gt;
  &lt;streq&gt;&lt;left&gt;&RUN_GSI;&lt;/left&gt;&lt;right&gt;YES&lt;/right&gt;&lt;/streq&gt;
&lt;/dependency&gt;
</code></pre>

<p>The &amp;RUN_GSI; ENTITY would be declared in the XML header and it acts as the switch; modifying its value controls whether the GSI component is included in the workflow configuration.</p>

<h2>
<a id="the-strneq-tag" class="anchor" href="#the-strneq-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;strneq&gt; tag (version 1.2.2+)</h2>

<p>The string comparison tags can be used to create dependency switches in your XML that allow you to manually (but easily) turn parts of a workflow on/off.  This can be useful in cases where there are multiple possible workflow configurations that are very similar to each other.  Rather than creating and maintaining separate workflows for each mostly identical configuration, these switches can be used to define a single workflow that can then be configured for various scenarios. For example, you could use a &lt;strneq&gt; dependency to turn on the tasks that run only when the GSI is NOT turned "on":</p>

<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE workflow
[
 ...
  &lt;!ENTITY RUN_GSI "YES"&gt;
]&gt;

...

&lt;dependency&gt;
   &lt;strneq&gt;&lt;left&gt;&RUN_GSI;&lt;/left&gt;&lt;right&gt;YES&lt;/right&gt;&lt;/strneq&gt;
&lt;/dependency&gt;
</code></pre>

<p>The &amp;RUN_GSI; ENTITY would be declared in the XML header and it acts as the switch; modifying its value controls whether the non-GSI-only components are included in the workflow configuration.</p>

<h2>
<a id="the-true-tag" class="anchor" href="#the-true-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;/true&gt; tag (version 1.2.2+)</h2>

<p>The boolean constant tags function similarly to the string comparison flags.  Their intended purpose is to act as switches that allow you to configure a workflow definition by turning portions of the workflow on/off using an ENTITY</p>

<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE workflow
[
 ...
  &lt;!ENTITY RUN_GSI "&lt;/true&gt;"&gt;
]&gt;

...

&lt;dependency&gt;
  &RUN_GSI;
&lt;/dependency&gt;
</code></pre>

<p>The above illustrates how you could use an ENTITY assigned to &lt;/true&gt; in a task dependency to turn a task on.</p>
<h2>
<a id="the-false-tag" class="anchor" href="#the-false-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;/false&gt; tag (version 1.2.2+)</h2>

<p>The boolean constant tags function similarly to the string comparison flags.  Their intended purpose is to act as switches that allow you to configure a workflow definition by turning portions of the workflow on/off using an ENTITY</p>

<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE workflow
[
 ...
  &lt;!ENTITY RUN_GSI "&lt;/false&gt;"&gt;
]&gt;

...

&lt;dependency&gt;
  &RUN_GSI;
&lt;/dependency&gt;
</code></pre>

<p>The above illustrates how you could use an ENTITY assigned to &lt;/false&gt; in a task dependency to turn a task off.</p>

<h2>
<a id="the-sh-tag" class="anchor" href="#the-sh-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;sh&gt; tag (version 1.2.2+)</h2>

<p>The &lt;sh&gt; tag allows you to create a dependency whose value is determined by the exit status of a UNIX shell command.  If the exit status of the command is 0, the dependency evaluates to true.  Otherwise, the dependency evaluates to false.  This can simplify workflow dependencies for complex situations where a task's completion status may not convey enough information to decide whether or not to trigger downstream tasks.  A common workaround was to augment the task such that it creates "flag" files that are then used in downstream &lt;datadep&gt; dependencies.  The &lt;sh&gt; tag is a simpler alternative.</p>

<pre><code>&lt;dependency&gt;
  &lt;sh&gt;grep 'RUN_COUPLED=YES' /path/to/file/ocean_status&lt;&lt;/sh&gt;
&lt;/dependency&gt;
</code></pre>

<p>The above is an example about how you might use a &lt;sh&gt; tag in a dependency to trigger parts of a workflow that depend on different workflow scenarios that are determined at runtime.</p>
<h2>
<a id="the-rb-tag" class="anchor" href="#the-rb-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;rb&gt; tag (version 1.2.2+)</h2>

<p> </p>

<pre><code> 
</code></pre>

<h2>
<a id="the-cycleexistdep-tag" class="anchor" href="#the-cycleexistdep-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;cycleexistdep&gt; tag (version 1.2.2+)</h2>

<p> </p>

<pre><code> 
</code></pre>


<h2>
<a id="the-boolean-operator-tags" class="anchor" href="#the-boolean-operator-tags" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The boolean operator tags</h2>

<p>There are several boolean operators that may be used to compose boolean expressions of dependencies. The operators and the operands (&lt;taskdep&gt;, &lt;datadep&gt;, &lt;timedep&gt;) can be combined without limit. The following lists the functions of the operators:</p>

<p> Satisfied if all enclosed dependencies are satisfied
  Satisfied if at least one of the enclosed dependencies is satisfied
  Satisfied if the enclosed dependency is not satisfied
  Satisfied if at least one of the enclosed dependencies is not satisfied
  Satisfied if none of the enclosed dependencies are satisfied
  Satisfied if exactly one of the enclosed dependencies is satisfied
  Satisfied if the fraction of enclosed dependencies that are satisfied exceeds some threshold (0 &lt;= threshold &lt;=1)</p>

<p>The example below illustrates how a complex dependency can be created. The example says "start this task if it is at least 25 minutes past the cycle time, and either (1) it is at least 50 minutes past the cycle time, or (2) the one hour forecast is available, or (3) It is at least 45 minutes past the cycle time and at least one of the 2,3,4,5, or 6 hour forecasts is available"</p>

<pre><code>  &lt;dependency&gt;
    &lt;and&gt;
        &lt;timedep&gt;&lt;cyclestr offset="25:00"&gt;@Y@m@d@H@M@S&lt;/cyclestr&gt;&lt;/timedep&gt;
        &lt;or&gt;
          &lt;timedep&gt;&lt;cyclestr offset="50:00"&gt;@Y@m@d@H@M@S&lt;/cyclestr&gt;&lt;/timedep&gt;
          &lt;datadep age="120"&gt;&lt;cyclestr offset="-1:00:00"&gt;&amp;WRF_HOME;/postprd/@Y@m@d@H000001.grib&lt;/cyclestr&gt;&lt;/datadep&gt;
          &lt;and&gt;
             &lt;timedep&gt;&lt;cyclestr offset="45:00"&gt;@Y@m@d@H@M@S&lt;/cyclestr&gt;&lt;/timedep&gt;
             &lt;or&gt; 
                &lt;datadep age="120"&gt;&lt;cyclestr offset="-2:00:00"&gt;&amp;WRF_HOME;/postprd/@Y@m@d@H000002.grib&lt;/cyclestr&gt;&lt;/datadep&gt;
                &lt;datadep age="120"&gt;&lt;cyclestr offset="-3:00:00"&gt;&amp;WRF_HOME;/postprd/@Y@m@d@H000003.grib&lt;/cyclestr&gt;&lt;/datadep&gt;
                &lt;datadep age="120"&gt;&lt;cyclestr offset="-4:00:00"&gt;&amp;WRF_HOME;/postprd/@Y@m@d@H000004.grib&lt;/cyclestr&gt;&lt;/datadep&gt;
                &lt;datadep age="120"&gt;&lt;cyclestr offset="-5:00:00"&gt;&amp;WRF_HOME;/postprd/@Y@m@d@H000005.grib&lt;/cyclestr&gt;&lt;/datadep&gt;
                &lt;datadep age="120"&gt;&lt;cyclestr offset="-6:00:00"&gt;&amp;WRF_HOME;/postprd/@Y@m@d@H000006.grib&lt;/cyclestr&gt;&lt;/datadep&gt;
             &lt;/or&gt;
          &lt;/and&gt;
       &lt;/or&gt; 
    &lt;/and&gt; 
  &lt;/dependency&gt;
</code></pre>

<h2>
<a id="the-hangdependency-tag" class="anchor" href="#the-hangdependency-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;hangdependency&gt; tag</h2>

<p>The &lt;hangdependency&gt; tag is used to specify a condition which indicates a task has hung. This is useful for situations where a system or programming error has caused a job to hang. This tag tells Rocoto how to distinguish between a job that is running normally, and one that is hung. The &lt;hangdependency&gt; works the same way the &lt;dependency&gt; tag does. However, when a &lt;hangdependency&gt; is satisfied, the job associated with the task is killed. The task will be retried if the maximum retry count has not been exceeded. A common way to use this is to use a &lt;datadep&gt; with a relatively long age attribute on an output file with the idea of detecting when a job stops writing output.</p>

<h2>
<a id="the-metatask-tag" class="anchor" href="#the-metatask-tag" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The &lt;metatask&gt; tag</h2>

<p>&lt;Metatask&gt; tags are used to define large groups of tasks that are very similar to each other. For example, it is often the case that the post-processing portion of a workflow contains many tasks which are nearly identical. In some cases, the only difference between these tasks is the name of the model output file that they process. Another example is ensembles. For an ensemble, the only difference between some tasks might be an environment variable that contains the ensemble member ID. Long lists of tasks that are nearly identical are difficult to maintain. The &lt;metatask&gt; tag allows one to create a template for a set of tasks. This template specifies the things that change, and the list of values for each of the items that vary. When Rocoto parses the XML, it expands the metatask, duplicating the task template for each value in the lists of items that change. This allows for a compact representation of a large number of nearly identical tasks, and facilitates maintenance of the workflow definition. A &lt;metatask&gt; tag can be used inside &lt;workflow&gt; tags or inside other &lt;metatask&gt; tags (yes, they can be nested).</p>

<p>The best way to explain &lt;metatask&gt; tags is to show an example (many details have been removed for clarity):</p>

<pre><code>  &lt;workflow&gt;

    &lt;metatask&gt;

      &lt;var name="var1"&gt;item1 item2 itemN&lt;/var&gt;
      &lt;var name="var2"&gt;itemA itemB itemZ&lt;/var&gt;

      &lt;task name="mytask_#var1#"&gt;

        &lt;envar&gt; 
          &lt;name&gt;MyVar&lt;/name&gt;
          &lt;value&gt;MyValue_#var2#&lt;/value&gt;
        &lt;/envar&gt; 

      &lt;/task&gt;

    &lt;/metatask&gt;

  &lt;/workflow&gt;
</code></pre>

<p>The lines above define a &lt;metatask&gt; that contains two metatask &lt;var&gt; tags and one &lt;task&gt; tag. Every &lt;metatask&gt; must contain at least one &lt;var&gt; tag. The &lt;var&gt; tags are used to define variables that can be referenced in the rest of the &lt;metatask&gt; using the #varname# syntax. In the example above, two metatask variables, var1 and var2, are defined. Each &lt;var&gt; tag contains a list of values, separated by spaces. All the &lt;var&gt; tags of a given &lt;metatask&gt; must contain the same number of values. The number of values in the &lt;var&gt; tags determines how many tasks are represented by the &lt;metatask&gt;. When Rocoto parses the XML, it expands &lt;metatask&gt; tags into the full set of tasks which they represent. This is done by iterating over the list of values specified in the &lt;var&gt; tags and creating one instance of the contents of the &lt;metatask&gt; for each value. For example, the &lt;metatask&gt; above will automatically be expanded to the following XML:</p>

<pre><code>  &lt;workflow&gt;

     &lt;task name="mytask_item1"&gt;

        &lt;envar&gt; 
           &lt;name&gt;MyVar&lt;/name&gt;
           &lt;value&gt;MyValue_itemA&lt;/value&gt;
        &lt;/envar&gt; 

     &lt;/task

     &lt;task name="mytask_item2"&gt;

        &lt;envar&gt; 
           &lt;name&gt;MyVar&lt;/name&gt;
           &lt;value&gt;MyValue_itemB&lt;/value&gt;
        &lt;/envar&gt; 

     &lt;/task

     &lt;task name="mytask_itemN"&gt;

         &lt;envar&gt; 
           &lt;name&gt;MyVar&lt;/name&gt;
           &lt;value&gt;MyValue_itemZ&lt;/value&gt;
        &lt;/envar&gt; 

     &lt;/task

  &lt;/workflow&gt;
</code></pre>

<p>Since a &lt;metatask&gt; can contain other &lt;metatask&gt; tags, you can represent a set of tasks that vary along multiple dimensions. For example, if you wanted to represent the post-processing tasks for a 10 member ensemble, where there is one post task for each model output file, you could use something like this:</p>

<pre><code>  &lt;metatask&gt;

      &lt;var name="member"&gt;01 02 03 04 05 06 07 08 09 10&lt;/var&gt;

      &lt;metatask&gt;

         &lt;var name="forecast"&gt;00 03 06 09 12 15 18 21 24 27 30 33 36 39 42 45 48&lt;/var&gt;

         &lt;task name="post_#member#_#forecast#"&gt;

            &lt;envar&gt;
               &lt;name&gt;MEMBER_ID&lt;/name&gt;
               &lt;value&gt;#member#&lt;/value&gt;
            &lt;/envar&gt;

            &lt;envar&gt;
               &lt;name&gt;FCST&lt;/name&gt;
               &lt;value&gt;#forecast#&lt;/name&gt;
            &lt;/envar&gt;

         &lt;/task&gt;

      &lt;/metatask&gt;

  &lt;/metatask&gt;
</code></pre>

<p>The above would create tasks for each possible pair of values in the member and forecast &lt;var&gt; tags. The above represents 170 tasks with only one block of XML!</p>

<p>The name attribute (version 1.1 and higher)</p>

<p>The name attribute is optional and can be used to assign a name to a &lt;metatask&gt;. The name can then be referenced in &lt;metataskdep&gt; tags to declare dependencies on the entire contents of a &lt;metatask&gt;. All &lt;metatask&gt; name attributes must be unique.</p>

<h3>
<a id="the-mode-attribute-version-11-and-higher" class="anchor" href="#the-mode-attribute-version-11-and-higher" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The mode attribute (version 1.1 and higher)</h3>

<p>The mode attribute is optional and is used to tell Rocoto if the contents of the &lt;metatask&gt; tag are to be run in parallel or in sequential order. The mode may either be "serial" or "parallel". The default mode is "parallel". If the mode is "serial" the &lt;metatask&gt; tag's immediate children will be run in sequential order. The task dependencies required to accomplish execution in sequential order will be inserted automatically. If a &lt;metatask&gt; contains another &lt;metatask&gt;, the contents of the enclosed &lt;metatask&gt; will not be serialized unless its mode attribute is also set to "serial".</p>

<p>Consider the following example, which is a slight variation of the example above, that illustrates the use of the name and mode attributes</p>

<pre><code>  &lt;metatask name="posts"&gt;

      &lt;var name="member"&gt;01 02 03 04 05 06 07 08 09 10&lt;/var&gt;

      &lt;metatask mode="serial"&gt;

         &lt;var name="forecast"&gt;00 03 06 09 12 15 18 21 24 27 30 33 36 39 42 45 48&lt;/var&gt;

         &lt;task name="post_#member#_#forecast#"&gt;

            &lt;envar&gt;
               &lt;name&gt;MEMBER_ID&lt;/name&gt;
               &lt;value&gt;#member#&lt;/value&gt;
            &lt;/envar&gt;

            &lt;envar&gt;
               &lt;name&gt;FCST&lt;/name&gt;
               &lt;value&gt;#forecast#&lt;/name&gt;
            &lt;/envar&gt;

         &lt;/task&gt;

      &lt;/metatask&gt;

  &lt;/metatask&gt;

  &lt;task name="hurricane_track_plots" ..... &gt;
   .
   .
   .
    &lt;dependency&gt;
      &lt;metataskdep metatask="posts"/&gt;
    &lt;/dependency&gt;

  &lt;/task&gt;
</code></pre>

<p>The above shows a &lt;metatask&gt; named "posts" which contains all the post-processing tasks for all members of an ensemble. Inside "posts" is an unnamed &lt;metatask&gt; that contains the post tasks for each forecast lead time for a given ensemble member. The "mode" of the inner &lt;metatask&gt; is set to "serial", meaning that its contents must be run sequentially instead of in parallel. The "mode" of the "posts" metatask was not specified, so its contents can run in parallel. What the above means is that, for a given ensemble member, the post tasks can not run at the same time and must run one after the other, in order of forecast lead time. However, since there is no dependency between the post tasks of different ensemble members, the sequence of post tasks for a given member can run in parallel with the sequence of post tasks of any other member. Finally, at the bottom is a task with a &lt;metataskdep&gt; dependency. The &lt;metataskdep&gt; tag declares that the hurricane_track_plots task can not run until all tasks contained in the "posts" &lt;metatask&gt; are completed successfully (i.e. all posts for all forecast lead time for all ensemble members are done successfully).</p>
        </section>

        <footer>
          Rocoto is maintained by <a href="https://github.com/christopherwharrop">christopherwharrop</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
